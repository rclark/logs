[![Go](https://github.com/rclark/logs/actions/workflows/go.yml/badge.svg?branch=main)](https://github.com/rclark/logs/actions/workflows/go.yml)

# logs

A package to support context-based logging.

In most situations where you find yourself reading logs, you're trying to understand what happened during some "unit of work" that your application performed. For example, you might be troubleshooting a failure to respond to an HTTP request the way that you expected the application would respond. In that case, the HTTP request represents a "unit of work" in your application.

Often, applications will generate some unique identifier for each unit of work it performs. The application will make sure (using a package like `slog`) that every time a log is printed related to a unit of work, it includes the unique identifier. When troubleshooting, the process of reading logs then goes something like this:

1. Find _any log_ from the unit of work you're troubleshooting.
2. Get the unit of work's unique identifier.
3. Find all the other logs that share the same unique identifier.

This package instead encourages you to put all the log information from any single unit of work into a single log entry, printed as a JSON object. This makes all the data related to a unit of work easier to find, and it makes it easier to extract quantitative values (i.e. metrics) from your logs. Several commonly-used observability platforms give you tools to perform this kind of quantitative log analysis.

It is common that in a Go application, one unit of work will tend to share a single `context.Context` object. This package attaches a log entry to that context, and gives your application tools to manipulate the log entry as it performs each unit of work.

This approach to logging is more expensive, performance-wise, than standard logging. And it can take a little getting-used to for an application developer. Instead of thinking about log "messages", you begin thinking about log "data" that describes the actions your application performed not as prose, but as more primitive values like counts, flags, durations, etc. On the other end of that performance/learning tradeoff are massive improvements to a system's observability improvements.

{{if .Header -}}
	{{- .Header -}}
	{{- spacer -}}
{{- end -}}

{{- range .Packages -}}
	{{- template "package" . -}}
	{{- spacer -}}
{{- end -}}

{{- if .Footer -}}
	{{- .Footer -}}
	{{- spacer -}}
{{- end -}}

Generated by {{link "gomarkdoc" "https://github.com/princjef/gomarkdoc"}}
