package logs

import (
	"bytes"
	"io"
	"net/http"
	"time"
)

// MiddlewareOption is used to configure logs generated by the [Middleware].
type MiddlewareOption func(*option)

// DefaultLevel sets the default log level for the log entries produced by the
// [Middleware].
func DefaultLevel(level Level) MiddlewareOption {
	return MiddlewareOption(WithDefaultLevel(level))
}

// PrintLevel sets the minimum log level for printing log entries produced by
// the [Middleware].
func PrintLevel(level Level) MiddlewareOption {
	return MiddlewareOption(WithLevel(level))
}

// WithOutput sets the output for the log entries produced by the [Middleware].
func Output(out io.Writer) MiddlewareOption {
	return MiddlewareOption(WithOutput(out))
}

// WithTimer configures the middleware to use a custom timer for measuring
// request duration and the current time.
func WithTimer(t Timer) MiddlewareOption {
	return MiddlewareOption(WithCurrentTime(t))
}

// WithBody configures the middleware to write request bodies into each log
// entry. This option will have no effect unless [Middleware] is operating
// on a [FreeformEntry].
func WithBody() MiddlewareOption {
	return func(o *option) {
		o.body = true
	}
}

// WithAllHeaders configures the middleware to write all request headers into
// each log entry. This option will have no effect unless [Middleware] is
// operating on a [FreeformEntry].
func WithAllHeaders() MiddlewareOption {
	return func(o *option) {
		o.allHeaders = true
	}
}

// WithHeaders configures the middleware to write specific request headers into
// each log entry. This option will have no effect unless [Middleware] is
// operating on a [FreeformEntry].
func WithHeaders(headers ...string) MiddlewareOption {
	return func(o *option) {
		o.someHeaders = headers
	}
}

// Middleware adds structured, context-based logging to an HTTP handler. This
// variable's value changes when you change the package to [StructuredMode].
var Middleware func(opts ...MiddlewareOption) func(http.Handler) http.Handler = freeformMiddleware

// HttpData is the data structure for HTTP data that the middleware will apply
// to log entries under the `@http` key of a [FreeformEntry].
type HttpData struct {
	Method   string            `json:"method"`
	Path     string            `json:"path"`
	Headers  map[string]string `json:"headers,omitempty"`
	Body     string            `json:"body,omitempty"`
	Duration time.Duration     `json:"duration"`
}

type bodyWatcher struct {
	io.ReadCloser
	buf *bytes.Buffer
}

func (bw *bodyWatcher) Read(p []byte) (int, error) {
	n, err := bw.ReadCloser.Read(p)
	if n > 0 {
		bw.buf.Write(p[:n])
	}
	return n, err
}

func freeformMiddleware(opts ...MiddlewareOption) func(http.Handler) http.Handler {
	return middleware(newFreeformEntry, opts...)
}

func middleware[T any](create EntryMaker[T], opts ...MiddlewareOption) func(http.Handler) http.Handler {
	logger := NewLogger(create)
	opt := applyOptions(opts...)

	var options = func(o *option) {
		*o = opt
	}

	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := opt.timer.Now()

			ctx := logger.AddEntry(r.Context(), options)
			data := HttpData{Method: r.Method, Path: r.URL.Path}
			isFreeform := Add(ctx, "@http", data)

			var buf *bytes.Buffer
			if isFreeform && opt.body {
				buf = new(bytes.Buffer)
				r.Body = &bodyWatcher{r.Body, buf}
			}

			next.ServeHTTP(w, r.WithContext(ctx))

			if isFreeform {
				data.Duration = opt.timer.Since(start)

				if opt.body {
					data.Body = buf.String()
				}

				if len(opt.someHeaders) > 0 {
					data.Headers = make(map[string]string)
					for _, h := range opt.someHeaders {
						data.Headers[h] = r.Header.Get(h)
					}
				} else if opt.allHeaders {
					data.Headers = make(map[string]string)
					for k := range r.Header {
						data.Headers[k] = r.Header.Get(k)
					}
				}

				Add(ctx, "@http", data)
			}

			logger.Print(ctx, options)
		})
	}
}
