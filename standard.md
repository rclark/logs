<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# logs

```go
import "github.com/rclark/logs"
```

Package logs offers structured, context\-based logging via two methods. The freeform method lets you create log entries by adding key\-value pairs to a [FreeformEntry](<#FreeformEntry>), which represents a log entry as a map with string keys and any values.

If you want more control or enforcement over the structure of your log entries, you can define a custom type for your logs. The [Logger](<#Logger>)'s methods uses this type for log entry manipulation. This will require you to pass the [Logger](<#Logger>) around in your application, but the [Logger.Set](<#Logger.Set>) and [Get](<#Get>) functions can help make that easier.

Alternatively, build your application with the "structuredlogs" tag. This exposes package\-level generic functions, similar to the freeform method, but using your custom type.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	ctx := logs.AddEntry(context.Background())

	logs.Add(ctx,
		"name", "test",
		"count", 42,
		"flag", true,
		"messages", []string{"hello", "world"},
	)

	logs.Print(ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","count":42,"flag":true,"messages":["hello","world"],"name":"test"}
```

</p>
</details>

<details><summary>Example (Log Levels)</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	// Will only print logs at or above INFO level.
	printOptions := []logs.PrintOption{
		logs.WithCurrentTime(time.Time{}),
		logs.WithLevel(logs.INFO),
	}

	ctx := logs.AddEntry(context.Background(), logs.WithDefaultLevel(logs.DEBUG))
	logs.Add(ctx, "this one", "is debug")
	logs.Print(ctx, printOptions...)

	ctx = logs.AddEntry(context.Background(), logs.WithDefaultLevel(logs.DEBUG))
	logs.Info(ctx)
	logs.Add(ctx, "this one", "is info")
	logs.Print(ctx, printOptions...)

	ctx = logs.AddEntry(context.Background(), logs.WithDefaultLevel(logs.DEBUG))
	logs.Warn(ctx)
	logs.Print(ctx, printOptions...)

	ctx = logs.AddEntry(context.Background(), logs.WithDefaultLevel(logs.DEBUG))
	logs.Error(ctx)
	logs.Add(ctx, "this one", "is error")
	logs.Print(ctx, printOptions...)
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","this one":"is info"}
{"@level":"WARN","@time":"0001-01-01T00:00:00Z"}
{"@level":"ERROR","@time":"0001-01-01T00:00:00Z","this one":"is error"}
```

</p>
</details>

## Index

- [func Add\(ctx context.Context, args ...any\) bool](<#Add>)
- [func AddEntry\(ctx context.Context, opts ...Option\) context.Context](<#AddEntry>)
- [func Adjust\(ctx context.Context, fns ...func\(\*FreeformEntry\)\) bool](<#Adjust>)
- [func Append\[T any\]\(ctx context.Context, key string, values ...T\) bool](<#Append>)
- [func Debug\(ctx context.Context\) bool](<#Debug>)
- [func Error\(ctx context.Context\) bool](<#Error>)
- [func Fatal\(ctx context.Context\) bool](<#Fatal>)
- [func Info\(ctx context.Context\) bool](<#Info>)
- [func Middleware\(opts ...MiddlewareOption\) func\(http.Handler\) http.Handler](<#Middleware>)
- [func Print\(ctx context.Context, opts ...PrintOption\) bool](<#Print>)
- [func Warn\(ctx context.Context\) bool](<#Warn>)
- [type EntryMaker](<#EntryMaker>)
- [type ExampleLog](<#ExampleLog>)
  - [func NewExampleLog\(\) \*ExampleLog](<#NewExampleLog>)
- [type FreeformEntry](<#FreeformEntry>)
  - [func GetEntry\(ctx context.Context\) \*FreeformEntry](<#GetEntry>)
- [type HttpData](<#HttpData>)
- [type Level](<#Level>)
  - [func \(l Level\) String\(\) string](<#Level.String>)
- [type Logger](<#Logger>)
  - [func Get\[T any\]\(ctx context.Context\) \*Logger\[T\]](<#Get>)
  - [func NewLogger\[T any\]\(create EntryMaker\[T\]\) Logger\[T\]](<#NewLogger>)
  - [func \(logger Logger\[T\]\) AddEntry\(ctx context.Context, opts ...Option\) context.Context](<#Logger[T].AddEntry>)
  - [func \(Logger\[T\]\) Adjust\(ctx context.Context, fns ...adjuster\[T\]\) bool](<#Logger[T].Adjust>)
  - [func \(Logger\[T\]\) Debug\(ctx context.Context\) bool](<#Logger[T].Debug>)
  - [func \(Logger\[T\]\) Error\(ctx context.Context\) bool](<#Logger[T].Error>)
  - [func \(Logger\[T\]\) Fatal\(ctx context.Context\) bool](<#Logger[T].Fatal>)
  - [func \(Logger\[T\]\) GetEntry\(ctx context.Context\) \*T](<#Logger[T].GetEntry>)
  - [func \(Logger\[T\]\) Info\(ctx context.Context\) bool](<#Logger[T].Info>)
  - [func \(logger Logger\[T\]\) Middleware\(opts ...MiddlewareOption\) func\(http.Handler\) http.Handler](<#Logger[T].Middleware>)
  - [func \(Logger\[T\]\) Print\(ctx context.Context, opts ...PrintOption\) bool](<#Logger[T].Print>)
  - [func \(logger Logger\[T\]\) Set\(ctx context.Context\) context.Context](<#Logger[T].Set>)
  - [func \(s Logger\[T\]\) Warn\(ctx context.Context\) bool](<#Logger[T].Warn>)
- [type MiddlewareOption](<#MiddlewareOption>)
  - [func DefaultLevel\(level Level\) MiddlewareOption](<#DefaultLevel>)
  - [func Output\(out io.Writer\) MiddlewareOption](<#Output>)
  - [func PrintLevel\(level Level\) MiddlewareOption](<#PrintLevel>)
  - [func WithAllHeaders\(\) MiddlewareOption](<#WithAllHeaders>)
  - [func WithBody\(\) MiddlewareOption](<#WithBody>)
  - [func WithHeaders\(headers ...string\) MiddlewareOption](<#WithHeaders>)
  - [func WithTiming\(now time.Time, since time.Duration\) MiddlewareOption](<#WithTiming>)
- [type Option](<#Option>)
  - [func WithDefaultLevel\(level Level\) Option](<#WithDefaultLevel>)
- [type PrintOption](<#PrintOption>)
  - [func WithCurrentTime\(now time.Time\) PrintOption](<#WithCurrentTime>)
  - [func WithLevel\(level Level\) PrintOption](<#WithLevel>)
  - [func WithOutput\(out io.Writer\) PrintOption](<#WithOutput>)
- [type Timer](<#Timer>)


<a name="Add"></a>
## func Add

```go
func Add(ctx context.Context, args ...any) bool
```

Add adds key\-value pairs to a freeform log entry. The function will return false if no freeform log entry is found in the context.

<details><summary>Example (Nested Keys)</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	ctx := logs.AddEntry(context.Background())

	logs.Add(ctx,
		"user.name", "test",
		"user.count", 42,
		"user.flags.flag", true,
	)

	logs.Print(ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","user":{"count":42,"flags":{"flag":true},"name":"test"}}
```

</p>
</details>

<a name="AddEntry"></a>
## func AddEntry

```go
func AddEntry(ctx context.Context, opts ...Option) context.Context
```

AddEntry adds a log entry to the context.

<a name="Adjust"></a>
## func Adjust

```go
func Adjust(ctx context.Context, fns ...func(*FreeformEntry)) bool
```

Adjust mutates the log entry in the context. The function will return false if no log entry of the correct type is found in the context.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	ctx := logs.AddEntry(context.Background())

	logs.Add(ctx,
		"count", 42,
	)

	logs.Adjust(ctx, func(fe *logs.FreeformEntry) {
		(*fe)["count"] = 43
	})

	logs.Print(ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","count":43}
```

</p>
</details>

<a name="Append"></a>
## func Append

```go
func Append[T any](ctx context.Context, key string, values ...T) bool
```

Append adds values to an existing key of the freeform log entry in the context. If the key does not exist, it will be created. The function will return false if no freeform log entry is found in the context, or if the key exists but its value is not \[\]T.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	ctx := logs.AddEntry(context.Background())

	logs.Add(ctx,
		"messages", []string{"hello", "world"},
	)

	logs.Append(ctx, "messages", "goodbye")

	logs.Print(ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","messages":["hello","world","goodbye"]}
```

</p>
</details>

<a name="Debug"></a>
## func Debug

```go
func Debug(ctx context.Context) bool
```

Debug sets the log entry's level to DEBUG. The function will return false if no log entry is found in the context.

<a name="Error"></a>
## func Error

```go
func Error(ctx context.Context) bool
```

Error sets the log entry's level to ERROR. The function will return false if no log entry is found in the context.

<a name="Fatal"></a>
## func Fatal

```go
func Fatal(ctx context.Context) bool
```

Fatal sets the log entry's level to FATAL. The function will return false if no log entry is found in the context.

<a name="Info"></a>
## func Info

```go
func Info(ctx context.Context) bool
```

Info sets the log entry's level to INFO. The function will return false if no log entry is found in the context.

<a name="Middleware"></a>
## func Middleware

```go
func Middleware(opts ...MiddlewareOption) func(http.Handler) http.Handler
```

Middleware adds structured, context\-based logging to an HTTP handler.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"strings"
	"time"

	"github.com/rclark/logs"
)

var freeformHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "failed to read body", http.StatusInternalServerError)
	}

	logs.Add(r.Context(),
		"messages", []string{"hello", "world"},
		"foo", string(body),
	)
})

func main() {
	middleware := logs.Middleware(logs.WithTiming(time.Time{}, time.Duration(1234)))

	w := httptest.NewRecorder()
	r := httptest.NewRequest(http.MethodPost, "/path", strings.NewReader("bar"))

	middleware(freeformHandler).ServeHTTP(w, r)
	if w.Code != http.StatusOK {
		log.Fatal("unexpected status code")
	}
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","@http":{"method":"POST","path":"/path","duration":1234},"foo":"bar","messages":["hello","world"]}
```

</p>
</details>

<details><summary>Example (All Headers)</summary>
<p>



```go
package main

import (
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"strings"
	"time"

	"github.com/rclark/logs"
)

var freeformHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "failed to read body", http.StatusInternalServerError)
	}

	logs.Add(r.Context(),
		"messages", []string{"hello", "world"},
		"foo", string(body),
	)
})

func main() {
	middleware := logs.Middleware(logs.WithTiming(time.Time{}, time.Duration(1234)), logs.WithAllHeaders())

	w := httptest.NewRecorder()
	r := httptest.NewRequest(http.MethodPost, "/path", strings.NewReader("bar"))
	r.Header.Set("X-Header", "x")
	r.Header.Set("Y-Header", "y")

	middleware(freeformHandler).ServeHTTP(w, r)
	if w.Code != http.StatusOK {
		log.Fatal("unexpected status code")
	}
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","@http":{"method":"POST","path":"/path","headers":{"X-Header":"x","Y-Header":"y"},"duration":1234},"foo":"bar","messages":["hello","world"]}
```

</p>
</details>

<details><summary>Example (Some Headers)</summary>
<p>



```go
package main

import (
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"strings"
	"time"

	"github.com/rclark/logs"
)

var freeformHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "failed to read body", http.StatusInternalServerError)
	}

	logs.Add(r.Context(),
		"messages", []string{"hello", "world"},
		"foo", string(body),
	)
})

func main() {
	middleware := logs.Middleware(logs.WithTiming(time.Time{}, time.Duration(1234)), logs.WithHeaders("X-Header"))

	w := httptest.NewRecorder()
	r := httptest.NewRequest(http.MethodPost, "/path", strings.NewReader("bar"))
	r.Header.Set("X-Header", "x")
	r.Header.Set("Y-Header", "y")

	middleware(freeformHandler).ServeHTTP(w, r)
	if w.Code != http.StatusOK {
		log.Fatal("unexpected status code")
	}
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","@http":{"method":"POST","path":"/path","headers":{"X-Header":"x"},"duration":1234},"foo":"bar","messages":["hello","world"]}
```

</p>
</details>

<details><summary>Example (With Body)</summary>
<p>



```go
package main

import (
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"strings"
	"time"

	"github.com/rclark/logs"
)

var freeformHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "failed to read body", http.StatusInternalServerError)
	}

	logs.Add(r.Context(),
		"messages", []string{"hello", "world"},
		"foo", string(body),
	)
})

func main() {
	middleware := logs.Middleware(logs.WithTiming(time.Time{}, time.Duration(1234)), logs.WithBody())

	w := httptest.NewRecorder()
	r := httptest.NewRequest(http.MethodPost, "/path", strings.NewReader("bar"))

	middleware(freeformHandler).ServeHTTP(w, r)
	if w.Code != http.StatusOK {
		log.Fatal("unexpected status code")
	}
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","@http":{"method":"POST","path":"/path","body":"bar","duration":1234},"foo":"bar","messages":["hello","world"]}
```

</p>
</details>

<a name="Print"></a>
## func Print

```go
func Print(ctx context.Context, opts ...PrintOption) bool
```

Print prints the log entry in the context as JSON. The function will return false if no log entry is found.

The default output is os.Stdout. You can change this by providing a custom io.Writer using the [WithOutput](<#WithOutput>) option.

The default log level for printing is INFO. You can change this by providing a custom log level using the [WithLevel](<#WithLevel>) option.

The default timer is the system clock. You can change this by providing a custom timer using the [WithCurrentTime](<#WithCurrentTime>) option. This is useful if you need to write tests to confirm that your application is logging as expected, as your custom timer can be used to control the log entry's "@time" property.

If the you've provided a custom struct for your log entries and it fails to marshal to JSON using the standard json.Marshal\(\), the function will write an error message to os.Stderr and return false.

<a name="Warn"></a>
## func Warn

```go
func Warn(ctx context.Context) bool
```

Warn sets the log entry's level to WARN. The function will return false if no log entry is found in the context.

<a name="EntryMaker"></a>
## type EntryMaker

EntryMaker is any function that creates a new, mutable log entry.

```go
type EntryMaker[T any] func() *T
```

<a name="ExampleLog"></a>
## type ExampleLog

ExampleLog is an example of a struct designed to be used as a log entry.

```go
type ExampleLog struct {
    Name     string   `json:"name"`
    Count    int      `json:"count"`
    Flag     bool     `json:"flag"`
    Messages []string `json:"messages,omitempty"`
}
```

<a name="NewExampleLog"></a>
### func NewExampleLog

```go
func NewExampleLog() *ExampleLog
```

NewExampleLog defines how to create an empty, mutable version of an [ExampleLog](<#ExampleLog>).

<a name="FreeformEntry"></a>
## type FreeformEntry

FreeformEntry is a freeform log entry.

```go
type FreeformEntry map[string]any
```

<a name="GetEntry"></a>
### func GetEntry

```go
func GetEntry(ctx context.Context) *FreeformEntry
```

GetFreeformEntry retrieves the freeform log entry from the context. The function will return nil if no freeform log entry is found in the context.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"log"
	"time"

	"github.com/rclark/logs"
)

func main() {
	ctx := logs.AddEntry(context.Background())

	logs.Add(ctx,
		"count", 42,
	)

	entry := logs.GetEntry(ctx)
	if entry == nil {
		log.Fatal("entry not found")
	}

	(*entry)["count"] = 43

	logs.Print(ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","count":43}
```

</p>
</details>

<a name="HttpData"></a>
## type HttpData

HttpData is the data structure for HTTP data that the middleware will apply to log entries under the \`@http\` key of a [FreeformEntry](<#FreeformEntry>).

```go
type HttpData struct {
    Method   string            `json:"method"`
    Path     string            `json:"path"`
    Headers  map[string]string `json:"headers,omitempty"`
    Body     string            `json:"body,omitempty"`
    Duration time.Duration     `json:"duration"`
}
```

<a name="Level"></a>
## type Level

Level represents the level of logging.

```go
type Level int
```

<a name="DEBUG"></a>

```go
const (
    // DEBUG is the lowest level of logging for your most verbose information.
    DEBUG Level = iota
    // INFO is the default logging level for general information.
    INFO
    // WARN is for logging more important information, but not critical.
    WARN
    // ERROR is for logging failures.
    ERROR
    // FATAL is for logging failures that are likely to crash your application.
    FATAL
)
```

<a name="Level.String"></a>
### func \(Level\) String

```go
func (l Level) String() string
```



<a name="Logger"></a>
## type Logger

Logger is a logger that logs structured data.

```go
type Logger[T any] struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	logger := logs.NewLogger(logs.NewExampleLog)

	ctx := logger.AddEntry(context.Background())

	logger.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Name = "test"
		e.Count = 42
		e.Flag = true
		e.Messages = []string{"hello", "world"}
	})

	logger.Print(ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"test","count":42,"flag":true,"messages":["hello","world"]}
```

</p>
</details>

<details><summary>Example (Log Levels)</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	// Will only print logs at or above INFO level.
	printOptions := []logs.PrintOption{
		logs.WithCurrentTime(time.Time{}),
		logs.WithLevel(logs.INFO),
	}

	logger := logs.NewLogger(logs.NewExampleLog)

	ctx := logger.AddEntry(context.Background())
	logger.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Messages = []string{"info"}
	})
	logger.Print(ctx, printOptions...)

	ctx = logger.AddEntry(context.Background())
	logger.Debug(ctx)
	logger.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Messages = []string{"debug"}
	})
	logger.Print(ctx, printOptions...)

	ctx = logger.AddEntry(context.Background())
	logger.Fatal(ctx)
	logger.Print(ctx, printOptions...)
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"","count":0,"flag":false,"messages":["info"]}
{"@level":"FATAL","@time":"0001-01-01T00:00:00Z","name":"","count":0,"flag":false}
```

</p>
</details>

<a name="Get"></a>
### func Get

```go
func Get[T any](ctx context.Context) *Logger[T]
```

Get retrieves the logger from the context. The function will return nil if no logger of the requested type is found.

<a name="NewLogger"></a>
### func NewLogger

```go
func NewLogger[T any](create EntryMaker[T]) Logger[T]
```

NewLogger creates a new structured logger for the logs of the specified type.

<a name="Logger[T].AddEntry"></a>
### func \(Logger\[T\]\) AddEntry

```go
func (logger Logger[T]) AddEntry(ctx context.Context, opts ...Option) context.Context
```

AddEntry adds a log entry to the context.

<a name="Logger[T].Adjust"></a>
### func \(Logger\[T\]\) Adjust

```go
func (Logger[T]) Adjust(ctx context.Context, fns ...adjuster[T]) bool
```

Adjust mutates the log entry in the context as JSON. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].Debug"></a>
### func \(Logger\[T\]\) Debug

```go
func (Logger[T]) Debug(ctx context.Context) bool
```

Debug sets the log entry's level to DEBUG and adds data to it. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].Error"></a>
### func \(Logger\[T\]\) Error

```go
func (Logger[T]) Error(ctx context.Context) bool
```

Error sets the log entry's level to ERROR and adds data to it. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].Fatal"></a>
### func \(Logger\[T\]\) Fatal

```go
func (Logger[T]) Fatal(ctx context.Context) bool
```

Fatal sets the log entry's level to FATAL and adds data to it. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].GetEntry"></a>
### func \(Logger\[T\]\) GetEntry

```go
func (Logger[T]) GetEntry(ctx context.Context) *T
```

GetEntry gets the log entry from the context for direct manipulation. The function will return nil if no log entry of the correct type is found in the context.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	logger := logs.NewLogger(logs.NewExampleLog)

	ctx := logger.AddEntry(context.Background())

	logger.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Name = "test"
		e.Count = 42
		e.Flag = true
		e.Messages = []string{"hello", "world"}
	})

	e := logger.GetEntry(ctx)
	if e != nil {
		e.Flag = false
	}

	logger.Print(ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"test","count":42,"flag":false,"messages":["hello","world"]}
```

</p>
</details>

<a name="Logger[T].Info"></a>
### func \(Logger\[T\]\) Info

```go
func (Logger[T]) Info(ctx context.Context) bool
```

Info sets the log entry's level to INFO and adds data to it. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].Middleware"></a>
### func \(Logger\[T\]\) Middleware

```go
func (logger Logger[T]) Middleware(opts ...MiddlewareOption) func(http.Handler) http.Handler
```

Middleware adds structured, context\-based logging to an HTTP handler. All requests will include a log entry in their context of the requested type.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"log"
	"net/http"
	"net/http/httptest"
	"time"

	"github.com/rclark/logs"
)

var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	logger := logs.Get[logs.ExampleLog](r.Context())
	if logger == nil {
		log.Fatal("logger not found")
	}

	logger.Adjust(r.Context(), func(e *logs.ExampleLog) {
		e.Name = "test"
		e.Count = 42
		e.Flag = true
		e.Messages = []string{"hello", "world"}
	})
})

func main() {
	logger := logs.NewLogger(logs.NewExampleLog)

	middleware := logger.Middleware(logs.WithTiming(time.Time{}, time.Duration(1234)))

	w := httptest.NewRecorder()
	r := httptest.NewRequest("GET", "/path", nil)

	middleware(handler).ServeHTTP(w, r)
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"test","count":42,"flag":true,"messages":["hello","world"]}
```

</p>
</details>

<a name="Logger[T].Print"></a>
### func \(Logger\[T\]\) Print

```go
func (Logger[T]) Print(ctx context.Context, opts ...PrintOption) bool
```

Print prints the log entry in the context as JSON. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].Set"></a>
### func \(Logger\[T\]\) Set

```go
func (logger Logger[T]) Set(ctx context.Context) context.Context
```

Set places the logger in the context.

<a name="Logger[T].Warn"></a>
### func \(Logger\[T\]\) Warn

```go
func (s Logger[T]) Warn(ctx context.Context) bool
```

Warn sets the log entry's level to WARN and adds data to it. The function will return false if no log entry of the correct type is found in the context.

<a name="MiddlewareOption"></a>
## type MiddlewareOption

MiddlewareOption is used to configure logs generated by the [Middleware](<#Middleware>).

```go
type MiddlewareOption func(*option)
```

<a name="DefaultLevel"></a>
### func DefaultLevel

```go
func DefaultLevel(level Level) MiddlewareOption
```

DefaultLevel sets the default log level for the log entries produced by the [Middleware](<#Middleware>).

<a name="Output"></a>
### func Output

```go
func Output(out io.Writer) MiddlewareOption
```

WithOutput sets the output for the log entries produced by the [Middleware](<#Middleware>).

<a name="PrintLevel"></a>
### func PrintLevel

```go
func PrintLevel(level Level) MiddlewareOption
```

PrintLevel sets the minimum log level for printing log entries produced by the [Middleware](<#Middleware>).

<a name="WithAllHeaders"></a>
### func WithAllHeaders

```go
func WithAllHeaders() MiddlewareOption
```

WithAllHeaders configures the middleware to write all request headers into each log entry. This option will have no effect unless [Middleware](<#Middleware>) is operating on a [FreeformEntry](<#FreeformEntry>).

<a name="WithBody"></a>
### func WithBody

```go
func WithBody() MiddlewareOption
```

WithBody configures the middleware to write request bodies into each log entry. This option will have no effect unless [Middleware](<#Middleware>) is operating on a [FreeformEntry](<#FreeformEntry>).

<a name="WithHeaders"></a>
### func WithHeaders

```go
func WithHeaders(headers ...string) MiddlewareOption
```

WithHeaders configures the middleware to write specific request headers into each log entry. This option will have no effect unless [Middleware](<#Middleware>) is operating on a [FreeformEntry](<#FreeformEntry>).

<a name="WithTiming"></a>
### func WithTiming

```go
func WithTiming(now time.Time, since time.Duration) MiddlewareOption
```

WithTiming configures the middleware to always print logs with the given timestamp and the given duration.

<a name="Option"></a>
## type Option

Option is configuration for a log entry.

```go
type Option func(*option)
```

<a name="WithDefaultLevel"></a>
### func WithDefaultLevel

```go
func WithDefaultLevel(level Level) Option
```

WithDefaultLevel sets the log level for the log entry. This can be overridden while collecting log data using functions like [Debug](<#Debug>) and [Error](<#Error>). The default level for an entry if this configuration option is not applied is INFO.

<a name="PrintOption"></a>
## type PrintOption

PrintOption is a configuration option for printing logs.

```go
type PrintOption func(*option)
```

<a name="WithCurrentTime"></a>
### func WithCurrentTime

```go
func WithCurrentTime(now time.Time) PrintOption
```

WithCurrentTime configures logs to always print with the same timestamp.

<a name="WithLevel"></a>
### func WithLevel

```go
func WithLevel(level Level) PrintOption
```

WithLevel sets the log level for printing the log entry. The default is INFO. If the log entry's level is less than the level set here, it will not be printed.

<a name="WithOutput"></a>
### func WithOutput

```go
func WithOutput(out io.Writer) PrintOption
```

WithOutput sets the output for the log entry. The default is os.Stdout.

<a name="Timer"></a>
## type Timer

Timer is an interface for measuring HTTP request duration. Provide your own implementation to use as a custom timer if you want to test your logging system.

```go
type Timer interface {
    Now() time.Time
    Since(time.Time) time.Duration
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
