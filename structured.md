<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# logs

```go
import "github.com/rclark/logs"
```

**Note**: This file documents the use of this package when built with a explicit build tag to put it into "structured mode"

```
go build -tags=structuredlogs
```

[Documentation for the build without this tag is available here](./standard.md).

Package logs enables structured, context\-aware logging with type enforcement. When built with the "structuredlogs" tag, you must define a custom type for your logs, create a [Logger](<#Logger>) for that type, and use [Logger.Set](<#Logger.Set>) to add it to the context. You may manipulate log entries using the [Logger](<#Logger>)'s methods or use the package\-level functions that work with your type.

Without the "structuredlogs" tag, logging is more flexible, allowing you to add any key\-value pairs to a log entry, represented as a map with string keys.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	ctx := logs.
		NewLogger(logs.NewExampleLog).
		Set(context.Background())

	ctx = logs.AddEntry[logs.ExampleLog](ctx)

	logs.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Name = "test"
		e.Count = 42
		e.Flag = true
		e.Messages = []string{"hello", "world"}
	})

	logs.Print[logs.ExampleLog](ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"test","count":42,"flag":true,"messages":["hello","world"]}
```

</p>
</details>

<details><summary>Example (Log Levels)</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	// Will only print logs at or above INFO level.
	printOptions := []logs.PrintOption{
		logs.WithCurrentTime(time.Time{}),
		logs.WithLevel(logs.INFO),
	}

	newCtx := func() context.Context {
		return logs.
			NewLogger(logs.NewExampleLog).
			Set(context.Background())
	}

	ctx := logs.AddEntry[logs.ExampleLog](newCtx(), logs.WithDefaultLevel(logs.DEBUG))
	logs.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Messages = []string{"debug"}
	})
	logs.Print[logs.ExampleLog](ctx, printOptions...)

	ctx = logs.AddEntry[logs.ExampleLog](newCtx(), logs.WithDefaultLevel(logs.DEBUG))
	logs.Info[logs.ExampleLog](ctx)
	logs.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Messages = []string{"info"}
	})
	logs.Print[logs.ExampleLog](ctx, printOptions...)

	ctx = logs.AddEntry[logs.ExampleLog](newCtx(), logs.WithDefaultLevel(logs.DEBUG))
	logs.Warn[logs.ExampleLog](ctx)
	logs.Print[logs.ExampleLog](ctx, printOptions...)

	ctx = logs.AddEntry[logs.ExampleLog](newCtx(), logs.WithDefaultLevel(logs.DEBUG))
	logs.Error[logs.ExampleLog](ctx)
	logs.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Messages = []string{"error"}
	})
	logs.Print[logs.ExampleLog](ctx, printOptions...)
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"","count":0,"flag":false,"messages":["info"]}
{"@level":"WARN","@time":"0001-01-01T00:00:00Z","name":"","count":0,"flag":false}
{"@level":"ERROR","@time":"0001-01-01T00:00:00Z","name":"","count":0,"flag":false,"messages":["error"]}
```

</p>
</details>

## Index

- [func AddEntry\[T any\]\(ctx context.Context, opts ...Option\) context.Context](<#AddEntry>)
- [func Adjust\[T any\]\(ctx context.Context, fns ...Adjuster\[T\]\) bool](<#Adjust>)
- [func Debug\[T any\]\(ctx context.Context\) bool](<#Debug>)
- [func Error\[T any\]\(ctx context.Context\) bool](<#Error>)
- [func Fatal\[T any\]\(ctx context.Context\) bool](<#Fatal>)
- [func GetEntry\[T any\]\(ctx context.Context\) \*T](<#GetEntry>)
- [func Info\[T any\]\(ctx context.Context\) bool](<#Info>)
- [func Middleware\[T any\]\(create EntryMaker\[T\], opts ...MiddlewareOption\) func\(http.Handler\) http.Handler](<#Middleware>)
- [func Print\[T any\]\(ctx context.Context, opts ...PrintOption\) bool](<#Print>)
- [func Warn\[T any\]\(ctx context.Context\) bool](<#Warn>)
- [type Adjuster](<#Adjuster>)
- [type EntryMaker](<#EntryMaker>)
- [type ExampleLog](<#ExampleLog>)
  - [func NewExampleLog\(\) \*ExampleLog](<#NewExampleLog>)
- [type Level](<#Level>)
  - [func \(l Level\) String\(\) string](<#Level.String>)
- [type Logger](<#Logger>)
  - [func Get\[T any\]\(ctx context.Context\) \*Logger\[T\]](<#Get>)
  - [func NewLogger\[T any\]\(create EntryMaker\[T\]\) Logger\[T\]](<#NewLogger>)
  - [func \(logger Logger\[T\]\) AddEntry\(ctx context.Context, opts ...Option\) context.Context](<#Logger[T].AddEntry>)
  - [func \(Logger\[T\]\) Adjust\(ctx context.Context, fns ...adjuster\[T\]\) bool](<#Logger[T].Adjust>)
  - [func \(Logger\[T\]\) Debug\(ctx context.Context\) bool](<#Logger[T].Debug>)
  - [func \(Logger\[T\]\) Error\(ctx context.Context\) bool](<#Logger[T].Error>)
  - [func \(Logger\[T\]\) Fatal\(ctx context.Context\) bool](<#Logger[T].Fatal>)
  - [func \(Logger\[T\]\) GetEntry\(ctx context.Context\) \*T](<#Logger[T].GetEntry>)
  - [func \(Logger\[T\]\) Info\(ctx context.Context\) bool](<#Logger[T].Info>)
  - [func \(logger Logger\[T\]\) Middleware\(opts ...MiddlewareOption\) func\(http.Handler\) http.Handler](<#Logger[T].Middleware>)
  - [func \(Logger\[T\]\) Print\(ctx context.Context, opts ...PrintOption\) bool](<#Logger[T].Print>)
  - [func \(logger Logger\[T\]\) Set\(ctx context.Context\) context.Context](<#Logger[T].Set>)
  - [func \(s Logger\[T\]\) Warn\(ctx context.Context\) bool](<#Logger[T].Warn>)
- [type MiddlewareOption](<#MiddlewareOption>)
  - [func DefaultLevel\(level Level\) MiddlewareOption](<#DefaultLevel>)
  - [func Output\(out io.Writer\) MiddlewareOption](<#Output>)
  - [func PrintLevel\(level Level\) MiddlewareOption](<#PrintLevel>)
  - [func WithTiming\(now time.Time, since time.Duration\) MiddlewareOption](<#WithTiming>)
- [type Option](<#Option>)
  - [func WithDefaultLevel\(level Level\) Option](<#WithDefaultLevel>)
- [type PrintOption](<#PrintOption>)
  - [func WithCurrentTime\(now time.Time\) PrintOption](<#WithCurrentTime>)
  - [func WithLevel\(level Level\) PrintOption](<#WithLevel>)
  - [func WithOutput\(out io.Writer\) PrintOption](<#WithOutput>)
- [type Timer](<#Timer>)


<a name="AddEntry"></a>
## func AddEntry

```go
func AddEntry[T any](ctx context.Context, opts ...Option) context.Context
```

AddEntry adds a log entry to the context. You must have first created a [Logger](<#Logger>) and added it to the context using the [Logger.Set](<#Logger.Set>) function.

<a name="Adjust"></a>
## func Adjust

```go
func Adjust[T any](ctx context.Context, fns ...Adjuster[T]) bool
```

Adjust mutates the log entry in the context. The function will return false if no log entry of the correct type is found in the context.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	ctx := logs.
		NewLogger(logs.NewExampleLog).
		Set(context.Background())

	ctx = logs.AddEntry[logs.ExampleLog](ctx)

	logs.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Name = "test"
		e.Count = 42
		e.Flag = true
		e.Messages = []string{"hello", "world"}
	})

	logs.Print[logs.ExampleLog](ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"test","count":42,"flag":true,"messages":["hello","world"]}
```

</p>
</details>

<a name="Debug"></a>
## func Debug

```go
func Debug[T any](ctx context.Context) bool
```

Debug sets the log entry's level to DEBUG. The function will return false if no log entry is found in the context.

<a name="Error"></a>
## func Error

```go
func Error[T any](ctx context.Context) bool
```

Error sets the log entry's level to ERROR. The function will return false if no log entry is found in the context.

<a name="Fatal"></a>
## func Fatal

```go
func Fatal[T any](ctx context.Context) bool
```

Fatal sets the log entry's level to FATAL. The function will return false if no log entry is found in the context.

<a name="GetEntry"></a>
## func GetEntry

```go
func GetEntry[T any](ctx context.Context) *T
```

GetEntry gets the log entry from the context for direct manipulation. The function will return nil if no log entry of the correct type is found.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"log"
	"time"

	"github.com/rclark/logs"
)

func main() {
	ctx := logs.
		NewLogger(logs.NewExampleLog).
		Set(context.Background())

	ctx = logs.AddEntry[logs.ExampleLog](ctx)

	logs.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Name = "test"
		e.Count = 42
		e.Flag = true
		e.Messages = []string{"hello", "world"}
	})

	e := logs.GetEntry[logs.ExampleLog](ctx)
	if e == nil {
		log.Fatal("entry not found")
	}

	e.Flag = false

	logs.Print[logs.ExampleLog](ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"test","count":42,"flag":false,"messages":["hello","world"]}
```

</p>
</details>

<a name="Info"></a>
## func Info

```go
func Info[T any](ctx context.Context) bool
```

Info sets the log entry's level to INFO. The function will return false if no log entry is found in the context.

<a name="Middleware"></a>
## func Middleware

```go
func Middleware[T any](create EntryMaker[T], opts ...MiddlewareOption) func(http.Handler) http.Handler
```

Middleware adds structured, context\-based logging to an HTTP handler. All requests will include a log entry in their context of the requested type.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"log"
	"net/http"
	"net/http/httptest"
	"time"

	"github.com/rclark/logs"
)

var structuredHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	logger := logs.Get[logs.ExampleLog](r.Context())
	if logger == nil {
		log.Fatal("logger not found")
	}

	logger.Adjust(r.Context(), func(e *logs.ExampleLog) {
		e.Name = "test"
		e.Count = 42
		e.Flag = true
		e.Messages = []string{"hello", "world"}
	})
})

func main() {
	middleware := logs.Middleware(logs.NewExampleLog, logs.WithTiming(time.Time{}, time.Duration(1234)))

	w := httptest.NewRecorder()
	r := httptest.NewRequest("GET", "/path", nil)

	middleware(structuredHandler).ServeHTTP(w, r)
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"test","count":42,"flag":true,"messages":["hello","world"]}
```

</p>
</details>

<a name="Print"></a>
## func Print

```go
func Print[T any](ctx context.Context, opts ...PrintOption) bool
```

Print prints the log entry in the context as JSON. The function will return false if no log entry is found.

The default output is os.Stdout. You can change this by providing a custom io.Writer using the [WithOutput](<#WithOutput>) option.

The default log level for printing is INFO. You can change this by providing a custom log level using the [WithLevel](<#WithLevel>) option.

The default timer is the system clock. You can change this by providing a custom timer using the [WithCurrentTime](<#WithCurrentTime>) option. This is useful if you need to write tests to confirm that your application is logging as expected, as your custom timer can be used to control the log entry's "@time" property.

If the you've provided a custom struct for your log entries and it fails to marshal to JSON using the standard json.Marshal\(\), the function will write an error message to os.Stderr and return false.

<a name="Warn"></a>
## func Warn

```go
func Warn[T any](ctx context.Context) bool
```

Warn sets the log entry's level to WARN. The function will return false if no log entry is found in the context.

<a name="Adjuster"></a>
## type Adjuster

Adjuster is a function that adjust a log entry.

```go
type Adjuster[T any] func(*T)
```

<a name="EntryMaker"></a>
## type EntryMaker

EntryMaker is any function that creates a new, mutable log entry.

```go
type EntryMaker[T any] func() *T
```

<a name="ExampleLog"></a>
## type ExampleLog

ExampleLog is an example of a struct designed to be used as a log entry.

```go
type ExampleLog struct {
    Name     string   `json:"name"`
    Count    int      `json:"count"`
    Flag     bool     `json:"flag"`
    Messages []string `json:"messages,omitempty"`
}
```

<a name="NewExampleLog"></a>
### func NewExampleLog

```go
func NewExampleLog() *ExampleLog
```

NewExampleLog defines how to create an empty, mutable version of an [ExampleLog](<#ExampleLog>).

<a name="Level"></a>
## type Level

Level represents the level of logging.

```go
type Level int
```

<a name="DEBUG"></a>

```go
const (
    // DEBUG is the lowest level of logging for your most verbose information.
    DEBUG Level = iota
    // INFO is the default logging level for general information.
    INFO
    // WARN is for logging more important information, but not critical.
    WARN
    // ERROR is for logging failures.
    ERROR
    // FATAL is for logging failures that are likely to crash your application.
    FATAL
)
```

<a name="Level.String"></a>
### func \(Level\) String

```go
func (l Level) String() string
```



<a name="Logger"></a>
## type Logger

Logger is a logger that logs structured data.

```go
type Logger[T any] struct {
    // contains filtered or unexported fields
}
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	logger := logs.NewLogger(logs.NewExampleLog)

	ctx := logger.AddEntry(context.Background())

	logger.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Name = "test"
		e.Count = 42
		e.Flag = true
		e.Messages = []string{"hello", "world"}
	})

	logger.Print(ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"test","count":42,"flag":true,"messages":["hello","world"]}
```

</p>
</details>

<details><summary>Example (Log Levels)</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	// Will only print logs at or above INFO level.
	printOptions := []logs.PrintOption{
		logs.WithCurrentTime(time.Time{}),
		logs.WithLevel(logs.INFO),
	}

	logger := logs.NewLogger(logs.NewExampleLog)

	ctx := logger.AddEntry(context.Background())
	logger.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Messages = []string{"info"}
	})
	logger.Print(ctx, printOptions...)

	ctx = logger.AddEntry(context.Background())
	logger.Debug(ctx)
	logger.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Messages = []string{"debug"}
	})
	logger.Print(ctx, printOptions...)

	ctx = logger.AddEntry(context.Background())
	logger.Fatal(ctx)
	logger.Print(ctx, printOptions...)
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"","count":0,"flag":false,"messages":["info"]}
{"@level":"FATAL","@time":"0001-01-01T00:00:00Z","name":"","count":0,"flag":false}
```

</p>
</details>

<a name="Get"></a>
### func Get

```go
func Get[T any](ctx context.Context) *Logger[T]
```

Get retrieves the logger from the context. The function will return nil if no logger of the requested type is found.

<a name="NewLogger"></a>
### func NewLogger

```go
func NewLogger[T any](create EntryMaker[T]) Logger[T]
```

NewLogger creates a new structured logger for the logs of the specified type.

<a name="Logger[T].AddEntry"></a>
### func \(Logger\[T\]\) AddEntry

```go
func (logger Logger[T]) AddEntry(ctx context.Context, opts ...Option) context.Context
```

AddEntry adds a log entry to the context.

<a name="Logger[T].Adjust"></a>
### func \(Logger\[T\]\) Adjust

```go
func (Logger[T]) Adjust(ctx context.Context, fns ...adjuster[T]) bool
```

Adjust mutates the log entry in the context as JSON. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].Debug"></a>
### func \(Logger\[T\]\) Debug

```go
func (Logger[T]) Debug(ctx context.Context) bool
```

Debug sets the log entry's level to DEBUG and adds data to it. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].Error"></a>
### func \(Logger\[T\]\) Error

```go
func (Logger[T]) Error(ctx context.Context) bool
```

Error sets the log entry's level to ERROR and adds data to it. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].Fatal"></a>
### func \(Logger\[T\]\) Fatal

```go
func (Logger[T]) Fatal(ctx context.Context) bool
```

Fatal sets the log entry's level to FATAL and adds data to it. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].GetEntry"></a>
### func \(Logger\[T\]\) GetEntry

```go
func (Logger[T]) GetEntry(ctx context.Context) *T
```

GetEntry gets the log entry from the context for direct manipulation. The function will return nil if no log entry of the correct type is found in the context.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"context"
	"time"

	"github.com/rclark/logs"
)

func main() {
	logger := logs.NewLogger(logs.NewExampleLog)

	ctx := logger.AddEntry(context.Background())

	logger.Adjust(ctx, func(e *logs.ExampleLog) {
		e.Name = "test"
		e.Count = 42
		e.Flag = true
		e.Messages = []string{"hello", "world"}
	})

	e := logger.GetEntry(ctx)
	if e != nil {
		e.Flag = false
	}

	logger.Print(ctx, logs.WithCurrentTime(time.Time{}))
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"test","count":42,"flag":false,"messages":["hello","world"]}
```

</p>
</details>

<a name="Logger[T].Info"></a>
### func \(Logger\[T\]\) Info

```go
func (Logger[T]) Info(ctx context.Context) bool
```

Info sets the log entry's level to INFO and adds data to it. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].Middleware"></a>
### func \(Logger\[T\]\) Middleware

```go
func (logger Logger[T]) Middleware(opts ...MiddlewareOption) func(http.Handler) http.Handler
```

Middleware adds structured, context\-based logging to an HTTP handler. All requests will include a log entry in their context of the requested type.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"log"
	"net/http"
	"net/http/httptest"
	"time"

	"github.com/rclark/logs"
)

var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	logger := logs.Get[logs.ExampleLog](r.Context())
	if logger == nil {
		log.Fatal("logger not found")
	}

	logger.Adjust(r.Context(), func(e *logs.ExampleLog) {
		e.Name = "test"
		e.Count = 42
		e.Flag = true
		e.Messages = []string{"hello", "world"}
	})
})

func main() {
	logger := logs.NewLogger(logs.NewExampleLog)

	middleware := logger.Middleware(logs.WithTiming(time.Time{}, time.Duration(1234)))

	w := httptest.NewRecorder()
	r := httptest.NewRequest("GET", "/path", nil)

	middleware(handler).ServeHTTP(w, r)
}
```

#### Output

```
{"@level":"INFO","@time":"0001-01-01T00:00:00Z","name":"test","count":42,"flag":true,"messages":["hello","world"]}
```

</p>
</details>

<a name="Logger[T].Print"></a>
### func \(Logger\[T\]\) Print

```go
func (Logger[T]) Print(ctx context.Context, opts ...PrintOption) bool
```

Print prints the log entry in the context as JSON. The function will return false if no log entry of the correct type is found in the context.

<a name="Logger[T].Set"></a>
### func \(Logger\[T\]\) Set

```go
func (logger Logger[T]) Set(ctx context.Context) context.Context
```

Set places the logger in the context.

<a name="Logger[T].Warn"></a>
### func \(Logger\[T\]\) Warn

```go
func (s Logger[T]) Warn(ctx context.Context) bool
```

Warn sets the log entry's level to WARN and adds data to it. The function will return false if no log entry of the correct type is found in the context.

<a name="MiddlewareOption"></a>
## type MiddlewareOption

MiddlewareOption is used to configure logs generated by the [Middleware](<#Middleware>).

```go
type MiddlewareOption func(*option)
```

<a name="DefaultLevel"></a>
### func DefaultLevel

```go
func DefaultLevel(level Level) MiddlewareOption
```

DefaultLevel sets the default log level for the log entries produced by the [Middleware](<#Middleware>).

<a name="Output"></a>
### func Output

```go
func Output(out io.Writer) MiddlewareOption
```

WithOutput sets the output for the log entries produced by the [Middleware](<#Middleware>).

<a name="PrintLevel"></a>
### func PrintLevel

```go
func PrintLevel(level Level) MiddlewareOption
```

PrintLevel sets the minimum log level for printing log entries produced by the [Middleware](<#Middleware>).

<a name="WithTiming"></a>
### func WithTiming

```go
func WithTiming(now time.Time, since time.Duration) MiddlewareOption
```

WithTiming configures the middleware to always print logs with the given timestamp and the given duration.

<a name="Option"></a>
## type Option

Option is configuration for a log entry.

```go
type Option func(*option)
```

<a name="WithDefaultLevel"></a>
### func WithDefaultLevel

```go
func WithDefaultLevel(level Level) Option
```

WithDefaultLevel sets the log level for the log entry. This can be overridden while collecting log data using functions like [Debug](<#Debug>) and [Error](<#Error>). The default level for an entry if this configuration option is not applied is INFO.

<a name="PrintOption"></a>
## type PrintOption

PrintOption is a configuration option for printing logs.

```go
type PrintOption func(*option)
```

<a name="WithCurrentTime"></a>
### func WithCurrentTime

```go
func WithCurrentTime(now time.Time) PrintOption
```

WithCurrentTime configures logs to always print with the same timestamp.

<a name="WithLevel"></a>
### func WithLevel

```go
func WithLevel(level Level) PrintOption
```

WithLevel sets the log level for printing the log entry. The default is INFO. If the log entry's level is less than the level set here, it will not be printed.

<a name="WithOutput"></a>
### func WithOutput

```go
func WithOutput(out io.Writer) PrintOption
```

WithOutput sets the output for the log entry. The default is os.Stdout.

<a name="Timer"></a>
## type Timer

Timer is an interface for measuring HTTP request duration. Provide your own implementation to use as a custom timer if you want to test your logging system.

```go
type Timer interface {
    Now() time.Time
    Since(time.Time) time.Duration
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
